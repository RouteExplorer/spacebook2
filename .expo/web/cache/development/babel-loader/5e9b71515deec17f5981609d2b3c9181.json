{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { PermissionStatus } from \"./Camera.types\";\nimport ExponentCamera from \"./ExponentCamera\";\nimport CameraManager from \"./ExponentCameraManager\";\nimport { ConversionTables, ensureNativeProps } from \"./utils/props\";\nvar EventThrottleMs = 500;\nvar _PICTURE_SAVED_CALLBACKS = {};\nvar _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options) {\n  var pictureOptions = !options || typeof options !== 'object' ? {} : options;\n\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n\n  if (pictureOptions.onPictureSaved) {\n    var id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n\n  return pictureOptions;\n}\n\nfunction ensureRecordingOptions(options) {\n  var recordingOptions = options || {};\n\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n\n  return recordingOptions;\n}\n\nfunction _onPictureSaved(_ref) {\n  var nativeEvent = _ref.nativeEvent;\n  var id = nativeEvent.id,\n      data = nativeEvent.data;\n  var callback = _PICTURE_SAVED_CALLBACKS[id];\n\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nvar Camera = function (_React$Component) {\n  _inherits(Camera, _React$Component);\n\n  var _super = _createSuper(Camera);\n\n  function Camera() {\n    var _this;\n\n    _classCallCheck(this, Camera);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._lastEvents = {};\n    _this._lastEventsTimes = {};\n\n    _this._onCameraReady = function () {\n      if (_this.props.onCameraReady) {\n        _this.props.onCameraReady();\n      }\n    };\n\n    _this._onMountError = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n\n      if (_this.props.onMountError) {\n        _this.props.onMountError(nativeEvent);\n      }\n    };\n\n    _this._onObjectDetected = function (callback) {\n      return function (_ref3) {\n        var nativeEvent = _ref3.nativeEvent;\n        var type = nativeEvent.type;\n\n        if (_this._lastEvents[type] && _this._lastEventsTimes[type] && JSON.stringify(nativeEvent) === _this._lastEvents[type] && new Date().getTime() - _this._lastEventsTimes[type].getTime() < EventThrottleMs) {\n          return;\n        }\n\n        if (callback) {\n          callback(nativeEvent);\n          _this._lastEventsTimes[type] = new Date();\n          _this._lastEvents[type] = JSON.stringify(nativeEvent);\n        }\n      };\n    };\n\n    _this._setReference = function (ref) {\n      if (ref) {\n        _this._cameraRef = ref;\n\n        if (Platform.OS === 'web') {\n          _this._cameraHandle = ref;\n        } else {\n          _this._cameraHandle = findNodeHandle(ref);\n        }\n      } else {\n        _this._cameraRef = null;\n        _this._cameraHandle = null;\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(Camera, [{\n    key: \"takePictureAsync\",\n    value: function takePictureAsync(options) {\n      var pictureOptions;\n      return _regeneratorRuntime.async(function takePictureAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pictureOptions = ensurePictureOptions(options);\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(CameraManager.takePicture(pictureOptions, this._cameraHandle));\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getSupportedRatiosAsync\",\n    value: function getSupportedRatiosAsync() {\n      return _regeneratorRuntime.async(function getSupportedRatiosAsync$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (CameraManager.getSupportedRatios) {\n                _context2.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n\n            case 2:\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getSupportedRatios(this._cameraHandle));\n\n            case 4:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getAvailablePictureSizesAsync\",\n    value: function getAvailablePictureSizesAsync(ratio) {\n      return _regeneratorRuntime.async(function getAvailablePictureSizesAsync$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (CameraManager.getAvailablePictureSizes) {\n                _context3.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n\n            case 2:\n              _context3.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle));\n\n            case 4:\n              return _context3.abrupt(\"return\", _context3.sent);\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"recordAsync\",\n    value: function recordAsync(options) {\n      var recordingOptions;\n      return _regeneratorRuntime.async(function recordAsync$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (CameraManager.record) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'recordAsync');\n\n            case 2:\n              recordingOptions = ensureRecordingOptions(options);\n              _context4.next = 5;\n              return _regeneratorRuntime.awrap(CameraManager.record(recordingOptions, this._cameraHandle));\n\n            case 5:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording() {\n      if (!CameraManager.stopRecording) {\n        throw new UnavailabilityError('Camera', 'stopRecording');\n      }\n\n      CameraManager.stopRecording(this._cameraHandle);\n    }\n  }, {\n    key: \"pausePreview\",\n    value: function pausePreview() {\n      if (!CameraManager.pausePreview) {\n        throw new UnavailabilityError('Camera', 'pausePreview');\n      }\n\n      CameraManager.pausePreview(this._cameraHandle);\n    }\n  }, {\n    key: \"resumePreview\",\n    value: function resumePreview() {\n      if (!CameraManager.resumePreview) {\n        throw new UnavailabilityError('Camera', 'resumePreview');\n      }\n\n      CameraManager.resumePreview(this._cameraHandle);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var nativeProps = ensureNativeProps(this.props);\n      var onBarCodeScanned = this.props.onBarCodeScanned ? this._onObjectDetected(this.props.onBarCodeScanned) : undefined;\n\n      var onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n\n      return React.createElement(ExponentCamera, _objectSpread(_objectSpread({}, nativeProps), {}, {\n        ref: this._setReference,\n        onCameraReady: this._onCameraReady,\n        onMountError: this._onMountError,\n        onBarCodeScanned: onBarCodeScanned,\n        onFacesDetected: onFacesDetected,\n        onPictureSaved: _onPictureSaved\n      }));\n    }\n  }], [{\n    key: \"isAvailableAsync\",\n    value: function isAvailableAsync() {\n      return _regeneratorRuntime.async(function isAvailableAsync$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (CameraManager.isAvailableAsync) {\n                _context5.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n\n            case 2:\n              _context5.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.isAvailableAsync());\n\n            case 4:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getAvailableCameraTypesAsync\",\n    value: function getAvailableCameraTypesAsync() {\n      return _regeneratorRuntime.async(function getAvailableCameraTypesAsync$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (CameraManager.getAvailableCameraTypesAsync) {\n                _context6.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n\n            case 2:\n              _context6.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getAvailableCameraTypesAsync());\n\n            case 4:\n              return _context6.abrupt(\"return\", _context6.sent);\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getAvailableVideoCodecsAsync\",\n    value: function getAvailableVideoCodecsAsync() {\n      return _regeneratorRuntime.async(function getAvailableVideoCodecsAsync$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (CameraManager.getAvailableVideoCodecsAsync) {\n                _context7.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n\n            case 2:\n              _context7.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getAvailableVideoCodecsAsync());\n\n            case 4:\n              return _context7.abrupt(\"return\", _context7.sent);\n\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getPermissionsAsync\",\n    value: function getPermissionsAsync() {\n      return _regeneratorRuntime.async(function getPermissionsAsync$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getCameraPermissionsAsync()\\\" or \\\"getMicrophonePermissionsAsync()\\\" instead.\");\n              return _context8.abrupt(\"return\", CameraManager.getPermissionsAsync());\n\n            case 2:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestPermissionsAsync\",\n    value: function requestPermissionsAsync() {\n      return _regeneratorRuntime.async(function requestPermissionsAsync$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestCameraPermissionsAsync()\\\" or \\\"requestMicrophonePermissionsAsync()\\\" instead.\");\n              return _context9.abrupt(\"return\", CameraManager.requestPermissionsAsync());\n\n            case 2:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getCameraPermissionsAsync\",\n    value: function getCameraPermissionsAsync() {\n      return _regeneratorRuntime.async(function getCameraPermissionsAsync$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", CameraManager.getCameraPermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestCameraPermissionsAsync\",\n    value: function requestCameraPermissionsAsync() {\n      return _regeneratorRuntime.async(function requestCameraPermissionsAsync$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              return _context11.abrupt(\"return\", CameraManager.requestCameraPermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getMicrophonePermissionsAsync\",\n    value: function getMicrophonePermissionsAsync() {\n      return _regeneratorRuntime.async(function getMicrophonePermissionsAsync$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              return _context12.abrupt(\"return\", CameraManager.getMicrophonePermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestMicrophonePermissionsAsync\",\n    value: function requestMicrophonePermissionsAsync() {\n      return _regeneratorRuntime.async(function requestMicrophonePermissionsAsync$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              return _context13.abrupt(\"return\", CameraManager.requestMicrophonePermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }]);\n\n  return Camera;\n}(React.Component);\n\nCamera.Constants = {\n  Type: CameraManager.Type,\n  FlashMode: CameraManager.FlashMode,\n  AutoFocus: CameraManager.AutoFocus,\n  WhiteBalance: CameraManager.WhiteBalance,\n  VideoQuality: CameraManager.VideoQuality,\n  VideoStabilization: CameraManager.VideoStabilization || {},\n  VideoCodec: CameraManager.VideoCodec\n};\nCamera.ConversionTables = ConversionTables;\nCamera.defaultProps = {\n  zoom: 0,\n  ratio: '4:3',\n  focusDepth: 0,\n  faceDetectorSettings: {},\n  type: CameraManager.Type.back,\n  autoFocus: CameraManager.AutoFocus.on,\n  flashMode: CameraManager.FlashMode.off,\n  whiteBalance: CameraManager.WhiteBalance.auto\n};\nCamera.useCameraPermissions = createPermissionHook({\n  getMethod: Camera.getCameraPermissionsAsync,\n  requestMethod: Camera.requestCameraPermissionsAsync\n});\nCamera.useMicrophonePermissions = createPermissionHook({\n  getMethod: Camera.getMicrophonePermissionsAsync,\n  requestMethod: Camera.requestMicrophonePermissionsAsync\n});\nexport { Camera as default };\nvar Constants = Camera.Constants,\n    getPermissionsAsync = Camera.getPermissionsAsync,\n    requestPermissionsAsync = Camera.requestPermissionsAsync,\n    getCameraPermissionsAsync = Camera.getCameraPermissionsAsync,\n    requestCameraPermissionsAsync = Camera.requestCameraPermissionsAsync,\n    getMicrophonePermissionsAsync = Camera.getMicrophonePermissionsAsync,\n    requestMicrophonePermissionsAsync = Camera.requestMicrophonePermissionsAsync;\nexport { Constants, getPermissionsAsync, requestPermissionsAsync, getCameraPermissionsAsync, requestCameraPermissionsAsync, getMicrophonePermissionsAsync, requestMicrophonePermissionsAsync };\nexport { PermissionStatus };","map":{"version":3,"mappings":"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","names":["createPermissionHook","Platform","UnavailabilityError","React","PermissionStatus","ExponentCamera","CameraManager","ConversionTables","ensureNativeProps","EventThrottleMs","_PICTURE_SAVED_CALLBACKS","_GLOBAL_PICTURE_ID","ensurePictureOptions","options","pictureOptions","quality","onPictureSaved","id","fastMode","ensureRecordingOptions","recordingOptions","Camera","Constants","VideoQuality","_onPictureSaved","nativeEvent","data","callback","_lastEvents","_lastEventsTimes","_onCameraReady","props","onCameraReady","_onMountError","onMountError","_onObjectDetected","type","JSON","stringify","Date","getTime","_setReference","ref","_cameraRef","OS","_cameraHandle","findNodeHandle","takePicture","getSupportedRatios","ratio","getAvailablePictureSizes","record","stopRecording","pausePreview","resumePreview","nativeProps","onBarCodeScanned","undefined","onFacesDetected","isAvailableAsync","getAvailableCameraTypesAsync","getAvailableVideoCodecsAsync","console","warn","getPermissionsAsync","requestPermissionsAsync","getCameraPermissionsAsync","requestCameraPermissionsAsync","getMicrophonePermissionsAsync","requestMicrophonePermissionsAsync","Component","Type","FlashMode","AutoFocus","WhiteBalance","VideoStabilization","VideoCodec","defaultProps","zoom","focusDepth","faceDetectorSettings","back","autoFocus","on","flashMode","off","whiteBalance","auto","useCameraPermissions","getMethod","requestMethod","useMicrophonePermissions"],"sourceRoot":"","sources":["../src/Camera.tsx"],"sourcesContent":["import { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { findNodeHandle } from 'react-native';\n\nimport {\n  BarCodeScanningResult,\n  CameraCapturedPicture,\n  CameraMountError,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraProps,\n  CameraRecordingOptions,\n  ConstantsType,\n  FaceDetectionResult,\n  PermissionExpiration,\n  PermissionResponse,\n  PermissionStatus,\n  VideoCodec,\n} from './Camera.types';\nimport ExponentCamera from './ExponentCamera';\nimport CameraManager from './ExponentCameraManager';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS = {};\n\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  const pictureOptions: CameraPictureOptions =\n    !options || typeof options !== 'object' ? {} : options;\n\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n  if (pictureOptions.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n  return pictureOptions;\n}\n\nfunction ensureRecordingOptions(options?: CameraRecordingOptions): CameraRecordingOptions {\n  let recordingOptions = options || {};\n\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n\n  return recordingOptions;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class Camera extends React.Component<CameraProps> {\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return await CameraManager.isAvailableAsync();\n  }\n\n  static async getAvailableCameraTypesAsync(): Promise<('front' | 'back')[]> {\n    if (!CameraManager.getAvailableCameraTypesAsync) {\n      throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n    }\n\n    return await CameraManager.getAvailableCameraTypesAsync();\n  }\n\n  static async getAvailableVideoCodecsAsync(): Promise<string[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return await CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  static Constants: ConstantsType = {\n    Type: CameraManager.Type,\n    FlashMode: CameraManager.FlashMode,\n    AutoFocus: CameraManager.AutoFocus,\n    WhiteBalance: CameraManager.WhiteBalance,\n    VideoQuality: CameraManager.VideoQuality,\n    VideoStabilization: CameraManager.VideoStabilization || {},\n    VideoCodec: CameraManager.VideoCodec,\n  };\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraProps = {\n    zoom: 0,\n    ratio: '4:3',\n    focusDepth: 0,\n    faceDetectorSettings: {},\n    type: CameraManager.Type.back,\n    autoFocus: CameraManager.AutoFocus.on,\n    flashMode: CameraManager.FlashMode.off,\n    whiteBalance: CameraManager.WhiteBalance.auto,\n  };\n\n  /**\n   * @deprecated Use `getCameraPermissionsAync` or `getMicrophonePermissionsAsync` instead.\n   */\n  static async getPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"getPermissionsAsync()\" is now deprecated. Please use \"getCameraPermissionsAsync()\" or \"getMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.getPermissionsAsync();\n  }\n\n  /**\n   * @deprecated Use `requestCameraPermissionsAsync` or `requestMicrophonePermissionsAsync` instead.\n   */\n  static async requestPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestCameraPermissionsAsync()\" or \"requestMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.requestPermissionsAsync();\n  }\n\n  static async getCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getCameraPermissionsAsync();\n  }\n\n  static async requestCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the camera.\n   * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useCameraPermissions();\n   * ```\n   */\n  static useCameraPermissions = createPermissionHook({\n    getMethod: Camera.getCameraPermissionsAsync,\n    requestMethod: Camera.requestCameraPermissionsAsync,\n  });\n\n  static async getMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getMicrophonePermissionsAsync();\n  }\n\n  static async requestMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the microphone.\n   * This uses both `requestMicrophonePermissionsAsync` and `getMicrophonePermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useMicrophonePermissions();\n   * ```\n   */\n  static useMicrophonePermissions = createPermissionHook({\n    getMethod: Camera.getMicrophonePermissionsAsync,\n    requestMethod: Camera.requestMicrophonePermissionsAsync,\n  });\n\n  _cameraHandle?: number | null;\n  _cameraRef?: React.Component | null;\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture> {\n    const pictureOptions = ensurePictureOptions(options);\n\n    return await CameraManager.takePicture(pictureOptions, this._cameraHandle);\n  }\n\n  async getSupportedRatiosAsync(): Promise<string[]> {\n    if (!CameraManager.getSupportedRatios) {\n      throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n    }\n\n    return await CameraManager.getSupportedRatios(this._cameraHandle);\n  }\n\n  async getAvailablePictureSizesAsync(ratio?: string): Promise<string[]> {\n    if (!CameraManager.getAvailablePictureSizes) {\n      throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n    }\n    return await CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle);\n  }\n\n  async recordAsync(\n    options?: CameraRecordingOptions\n  ): Promise<{ uri: string; codec?: VideoCodec }> {\n    if (!CameraManager.record) {\n      throw new UnavailabilityError('Camera', 'recordAsync');\n    }\n\n    const recordingOptions = ensureRecordingOptions(options);\n    return await CameraManager.record(recordingOptions, this._cameraHandle);\n  }\n\n  stopRecording() {\n    if (!CameraManager.stopRecording) {\n      throw new UnavailabilityError('Camera', 'stopRecording');\n    }\n\n    CameraManager.stopRecording(this._cameraHandle);\n  }\n\n  pausePreview() {\n    if (!CameraManager.pausePreview) {\n      throw new UnavailabilityError('Camera', 'pausePreview');\n    }\n\n    CameraManager.pausePreview(this._cameraHandle);\n  }\n\n  resumePreview() {\n    if (!CameraManager.resumePreview) {\n      throw new UnavailabilityError('Camera', 'resumePreview');\n    }\n\n    CameraManager.resumePreview(this._cameraHandle);\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref?: React.Component) => {\n    if (ref) {\n      this._cameraRef = ref;\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      } else {\n        this._cameraHandle = findNodeHandle(ref);\n      }\n    } else {\n      this._cameraRef = null;\n      this._cameraHandle = null;\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n\n    const onBarCodeScanned = this.props.onBarCodeScanned\n      ? this._onObjectDetected(this.props.onBarCodeScanned)\n      : undefined;\n    const onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n\n    return (\n      <ExponentCamera\n        {...nativeProps}\n        ref={this._setReference}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarCodeScanned={onBarCodeScanned}\n        onFacesDetected={onFacesDetected}\n        onPictureSaved={_onPictureSaved}\n      />\n    );\n  }\n}\n\nexport const {\n  Constants,\n  getPermissionsAsync,\n  requestPermissionsAsync,\n  getCameraPermissionsAsync,\n  requestCameraPermissionsAsync,\n  getMicrophonePermissionsAsync,\n  requestMicrophonePermissionsAsync,\n} = Camera;\n\nexport {\n  CameraCapturedPicture,\n  CameraNativeProps,\n  CameraPictureOptions,\n  CameraProps,\n  CameraRecordingOptions,\n  PermissionResponse,\n  PermissionStatus,\n  PermissionExpiration,\n  BarCodeScanningResult,\n  FaceDetectionResult,\n  CameraMountError,\n};\n"]},"metadata":{},"sourceType":"module"}